# SSD Firmware Coverage-Guided Fuzzing Overview

## J-Link / Trace32 기반 커버리지 퍼징 with NVMe CLI Harness

---

## 1. 전체 시스템 Overview

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                                                                                 │
│                                HOST PC (Ubuntu)                                 │
│                                                                                 │
│  ┌───────────────────────────────────────────────────────────────────────────┐  │
│  │                          Fuzzing Engine                                   │  │
│  │                                                                           │  │
│  │   ┌───────────┐     ┌────────────┐     ┌────────────────────────────┐    │  │
│  │   │  Input    │────▶│  Corpus    │◀────│   Coverage Evaluator      │    │  │
│  │   │ Generator │     │  Manager   │     │   (새 경로 발견 여부)      │    │  │
│  │   │ (Mutator) │     │            │     └────────────┬───────────────┘    │  │
│  │   └───────────┘     └────────────┘                  │                    │  │
│  │                                                     │                    │  │
│  │         ┌───────────────────────────────────────────┘                    │  │
│  │         │                                                                │  │
│  │         ▼                                                                │  │
│  │   ┌──────────────────────────────────────────────────────────────────┐   │  │
│  │   │                  Coverage Backend (택 1)                         │   │  │
│  │   │                                                                  │   │  │
│  │   │   ┌─────────────────────┐     ┌─────────────────────────────┐   │   │  │
│  │   │   │ Option A: J-Link   │     │ Option B: Trace32           │   │   │  │
│  │   │   │ (PC Sampling)      │     │ (Real-time Trace)           │   │   │  │
│  │   │   │                    │     │                             │   │   │  │
│  │   │   │ Halt-Sample-Resume │     │ ARM ETM/CoreSight          │   │   │  │
│  │   │   │ pylink 라이브러리  │     │ PRACTICE Script            │   │   │  │
│  │   │   │ ~$50               │     │ ~$10,000+                   │   │   │  │
│  │   │   └─────────┬─────────┘     └──────────────┬──────────────┘   │   │  │
│  │   │             │                               │                  │   │  │
│  │   └─────────────┼───────────────────────────────┼──────────────────┘   │  │
│  │                  │                               │                      │  │
│  └──────────────────┼───────────────────────────────┼──────────────────────┘  │
│                     │                               │                         │
│  ┌──────────────────┼───────────────────────────────┼──────────────────────┐  │
│  │                  │      NVMe CLI Harness         │                      │  │
│  │                  │                               │                      │  │
│  │                  │     ┌─────────────────┐       │                      │  │
│  │                  │     │  nvme-cli       │       │                      │  │
│  │                  │     │                 │       │                      │  │
│  │                  │     │ admin-passthru  │       │                      │  │
│  │                  │     │ io-passthru     │       │                      │  │
│  │                  │     └────────┬────────┘       │                      │  │
│  │                  │              │                 │                      │  │
│  └──────────────────┼──────────────┼─────────────────┼──────────────────────┘  │
│                     │              │                 │                         │
└─────────────────────┼──────────────┼─────────────────┼─────────────────────────┘
                      │              │                 │
                      │ USB          │ PCIe/NVMe       │ USB / Ethernet
                      │              │                 │
                      ▼              ▼                 ▼
              ┌──────────┐                      ┌──────────┐
              │  J-Link  │                      │ Trace32  │
              │    V9    │                      │ PowerView│
              └────┬─────┘                      └────┬─────┘
                   │ JTAG                            │ JTAG/SWD
                   │                                 │
                   ▼                                 ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                                                                                 │
│                            TARGET SSD                                           │
│                          (ARM Cortex-R8)                                        │
│                                                                                 │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│   │   JTAG      │  │   NVMe      │  │  Flash      │  │    DRAM             │  │
│   │   Port      │  │ Interface   │  │ Controller  │  │                     │  │
│   └─────────────┘  └─────────────┘  └─────────────┘  └─────────────────────┘  │
│                                                                                 │
│   ┌─────────────────────────────────────────────────────────────────────────┐  │
│   │                         Firmware                                        │  │
│   │                                                                         │  │
│   │   ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────────┐   │  │
│   │   │ NVMe CMD   │  │  FTL       │  │  NAND      │  │  Error         │   │  │
│   │   │ Handler    │  │ (Flash     │  │  Driver    │  │  Handler       │   │  │
│   │   │            │  │ Translation│  │            │  │                │   │  │
│   │   │ Admin/IO   │  │ Layer)     │  │            │  │                │   │  │
│   │   └────────────┘  └────────────┘  └────────────┘  └────────────────┘   │  │
│   │                                                                         │  │
│   └─────────────────────────────────────────────────────────────────────────┘  │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 동작 원리

### 2.1 퍼징 루프

```
┌─────────────────────────────────────────────────────────────────┐
│                        Fuzzing Loop                              │
└─────────────────────────────────────────────────────────────────┘

 ① 입력 생성                  ② NVMe Harness               ③ 커버리지 수집
┌───────────────┐          ┌───────────────────┐         ┌───────────────────┐
│ Corpus에서    │          │ nvme-cli로        │         │ J-Link or Trace32 │
│ 기존 입력 선택│─mutation─▶│ SSD에 커맨드 전송 │──JTAG──▶│ 실행 경로 수집    │
│ + 변형       │          │                   │         │                   │
└───────────────┘          └───────────────────┘         └─────────┬─────────┘
       ▲                                                           │
       │                                                           ▼
       │                                                  ④ 커버리지 평가
       │                                                 ┌───────────────────┐
       │                                                 │ 새로운 코드 경로  │
       │              ⑤-B. Discard                       │ 발견했는가?       │
       │              (새 발견 없음)                      └─────────┬─────────┘
       │                                                           │
       │                           ┌───────────────────────────────┤
       │                           │                               │
       │                     Yes (새 경로!)                   No (기존 경로)
       │                           │                               │
       │                           ▼                               ▼
       │                ⑤-A. Corpus에 저장             입력 버림
       │                ┌───────────────────┐
       └────────────────│ 이 입력이 새로운  │
                        │ 코드를 실행함     │
                        │ → 보존!           │
                        └───────────────────┘
```

### 2.2 NVMe CLI Harness 상세

```
┌─────────────────────────────────────────────────────────────────┐
│                     NVMe CLI Harness                             │
└─────────────────────────────────────────────────────────────────┘

Fuzzer가 생성한 입력 (bytes)
        │
        ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. 입력 데이터를 파일로 저장                                    │
│     /tmp/nvme_fuzz_input                                        │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. NVMe 커맨드 타입 선택 (랜덤)                                │
│                                                                  │
│     ┌────────────────────────────────────────────────────────┐  │
│     │  Admin Commands           │  I/O Commands              │  │
│     │  (nvme admin-passthru)    │  (nvme io-passthru)        │  │
│     │                           │                            │  │
│     │  0x06 Identify            │  0x01 Write                │  │
│     │  0x02 Get Log Page        │  0x02 Read                 │  │
│     │  0x09 Set Features        │                            │  │
│     │  0x0A Get Features        │                            │  │
│     │  0xC0 Vendor Specific     │                            │  │
│     └────────────────────────────────────────────────────────┘  │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. nvme-cli 실행                                               │
│                                                                  │
│  $ nvme admin-passthru /dev/nvme0 \                             │
│        --opcode=0xC0 \                                          │
│        --input-file=/tmp/nvme_fuzz_input \                      │
│        --data-len=512 \                                         │
│        --timeout=5000                                           │
│                                                                  │
│  $ nvme io-passthru /dev/nvme0 \                                │
│        --opcode=0x01 \                                          │
│        --namespace-id=1 \                                       │
│        --input-file=/tmp/nvme_fuzz_input \                      │
│        --data-len=512                                           │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
                      ┌──────────────┐
                      │  SSD가 처리  │
                      └──────────────┘
```

---

## 3. Coverage Backend 비교

### 3.1 Option A: J-Link (PC Sampling)

```
┌─────────────────────────────────────────────────────────────────┐
│                   J-Link PC Sampling                             │
└─────────────────────────────────────────────────────────────────┘

방식: Halt → Read PC(R15) → Resume (반복)

Timeline:
════════════════════════════════════════════════════════════════════
 CPU:   ▓▓▓▓▓░▓▓▓▓▓░▓▓▓▓▓░▓▓▓▓▓░▓▓▓▓▓░▓▓▓▓▓░▓▓▓▓▓░▓▓▓▓▓
              │          │          │          │          │
              S1         S2         S3         S4         S5
              │          │          │          │          │
              ▼          ▼          ▼          ▼          ▼
           0x1234     0x1238     0x5678     0x5680     0x9ABC

         ▓ = Running    ░ = Halt (수 μs)    S = Sample

결과: Coverage Set = {0x1234, 0x1238, 0x5678, 0x5680, 0x9ABC}

장점                              단점
┌──────────────────────┐         ┌──────────────────────────┐
│ ✅ 저렴 (~$50)       │         │ ❌ 완전 Non-intrusive 아님│
│ ✅ 설정 간단          │         │ ❌ 샘플링 기반 (누락 가능)│
│ ✅ pylink로 자동화    │         │ ❌ 짧은 함수 놓칠 수 있음 │
│ ✅ 추가 하드웨어 불필요│         │ ❌ 속도 제한 있음         │
└──────────────────────┘         └──────────────────────────┘
```

### 3.2 Option B: Trace32 (Real-time Trace)

```
┌─────────────────────────────────────────────────────────────────┐
│                   Trace32 Real-time Trace                        │
└─────────────────────────────────────────────────────────────────┘

방식: ARM ETM/CoreSight → 실시간 명령어 트레이스

Timeline:
════════════════════════════════════════════════════════════════════
 CPU:   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
              ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑
              모든 실행 명령어를 기록 (CPU 멈추지 않음)

        ▓ = Running (계속 실행)    ↑ = Trace Point (모두 기록)

결과: 실행된 모든 주소 기록 (누락 없음)

장점                              단점
┌──────────────────────┐         ┌──────────────────────────┐
│ ✅ 완전 Non-intrusive │         │ ❌ 고가 (~$10,000+)      │
│ ✅ 모든 명령어 기록   │         │ ❌ Trace Port 필요       │
│ ✅ 누락 없음          │         │ ❌ PRACTICE 스크립트 학습 │
│ ✅ 정확한 BB 커버리지 │         │ ❌ SoC ETM 지원 필요     │
└──────────────────────┘         └──────────────────────────┘
```

### 3.3 비교 요약

```
┌──────────────┬─────────────────────┬─────────────────────────┐
│ 항목         │ J-Link (PC Sampling)│ Trace32 (ETM Trace)     │
├──────────────┼─────────────────────┼─────────────────────────┤
│ 가격         │ ~$50               │ ~$10,000+               │
│ 침습성       │ 최소 침습 (짧은 Halt)│ 완전 Non-intrusive      │
│ 커버리지     │ 확률적 (샘플링)     │ 정확 (모든 명령어)       │
│ 누락         │ 있음               │ 없음                     │
│ 속도         │ 중간               │ 빠름                     │
│ 설정 난이도  │ 낮음               │ 높음                     │
│ 자동화       │ Python (pylink)    │ PRACTICE Script / API    │
│ NVMe 영향    │ 거의 없음          │ 없음                     │
│ 적합한 단계  │ 초기 탐색, PoC     │ 정밀 퍼징, 프로덕션      │
└──────────────┴─────────────────────┴─────────────────────────┘
```

---

## 4. 커버리지 수집 방식 상세

### 4.1 J-Link: PC Set 기반

```
┌─────────────────────────────────────────────────────────────────┐
│             J-Link Coverage Model                                │
└─────────────────────────────────────────────────────────────────┘

수집 데이터: PC 주소의 집합 (Set)

Input A 실행 → {0x1000, 0x1004, 0x2000, 0x2004}
Input B 실행 → {0x1000, 0x1004, 0x3000, 0x3004}   ← 0x3000 새로 발견!
Input C 실행 → {0x1000, 0x1004, 0x2000}            ← 새 발견 없음

Global Coverage = {0x1000, 0x1004, 0x2000, 0x2004, 0x3000, 0x3004}

커버리지 단위: PC 주소 (≈ 명령어 레벨, 불완전)
정확도: 샘플링 주기에 의존 (모든 주소를 수집하진 못함)
```

### 4.2 Trace32: Basic Block / Edge 기반

```
┌─────────────────────────────────────────────────────────────────┐
│             Trace32 Coverage Model                               │
└─────────────────────────────────────────────────────────────────┘

수집 데이터: 실행된 모든 명령어 흐름

Input A 실행:
  0x1000 → 0x1004 → 0x1008 → [branch] → 0x2000 → 0x2004 → return

  Basic Blocks Hit: {BB_1000, BB_2000}
  Edges Hit: {BB_1000→BB_2000}

Input B 실행:
  0x1000 → 0x1004 → 0x1008 → [branch] → 0x3000 → 0x3004 → return

  Basic Blocks Hit: {BB_1000, BB_3000}        ← BB_3000 새로 발견!
  Edges Hit: {BB_1000→BB_3000}                ← Edge도 새로 발견!

커버리지 단위: Basic Block + Edge (완전)
정확도: 100% (모든 실행 경로 기록)
```

---

## 5. Trace32 통합 방법

### 5.1 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│               Trace32 Integration Architecture                   │
└─────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────┐
│                        Fuzzer (Python)                        │
│                                                              │
│  ┌──────────┐     ┌──────────────┐     ┌──────────────────┐ │
│  │ Mutator  │────▶│ NVMe Harness │     │ Coverage Parser  │ │
│  └──────────┘     └──────┬───────┘     └────────┬─────────┘ │
│                          │                      │            │
│                          │              ┌───────┴────────┐   │
│                          │              │ Trace32        │   │
│                          │              │ Remote API     │   │
│                          │              │ (t32rem / RCL) │   │
│                          │              └───────┬────────┘   │
└──────────────────────────┼──────────────────────┼────────────┘
                           │                      │
                           │ PCIe                  │ USB/Ethernet
                           │                      │
                           ▼                      ▼
                    ┌──────────┐           ┌──────────────┐
                    │   SSD    │◀──JTAG───│   Trace32    │
                    └──────────┘           │  PowerDebug  │
                                          └──────────────┘
```

### 5.2 Trace32 PRACTICE Script 예시

```
; trace32_coverage.cmm
; 커버리지 수집용 PRACTICE 스크립트

; 트레이스 초기화
Trace.METHOD Analyzer
Trace.Init

; 커버리지 모드 설정
Coverage.Init
Coverage.Method TraceCOVerage

; 커버리지 수집 시작
Coverage.ON

; ... (Fuzzer가 NVMe 명령 전송) ...

; 커버리지 결과 저장
Coverage.SAVE coverage_result.txt

; 또는 API로 읽기
; Python에서 t32api로 Coverage.ListFunc 결과를 파싱
```

### 5.3 Trace32 Python API 연동

```python
# trace32_sampler.py (개념 코드)
import t32api  # Trace32 Python Remote API

class Trace32Sampler:
    def __init__(self, host='localhost', port=20000):
        self.api = t32api.Connect(host, port)
        self.global_coverage = set()

    def start_trace(self):
        """트레이스 시작"""
        self.api.Cmd("Trace.Init")
        self.api.Cmd("Coverage.Init")
        self.api.Cmd("Coverage.ON")

    def stop_and_get_coverage(self) -> set:
        """트레이스 종료 및 커버리지 추출"""
        self.api.Cmd("Coverage.OFF")

        # 커버리지 데이터 읽기
        blocks = self.api.Cmd("Coverage.ListBlock")
        current = set()
        for block in blocks:
            current.add(block.address)

        return current

    def evaluate(self, current: set) -> bool:
        initial = len(self.global_coverage)
        self.global_coverage.update(current)
        return len(self.global_coverage) > initial
```

---

## 6. NVMe CLI Harness 상세

### 6.1 Harness 역할

```
┌─────────────────────────────────────────────────────────────────┐
│                    NVMe CLI Harness                              │
└─────────────────────────────────────────────────────────────────┘

역할: Fuzzer의 바이트 입력 → NVMe 프로토콜 명령으로 변환

┌──────────────┐        ┌──────────────────┐        ┌─────────┐
│ Fuzz Input   │───────▶│  NVMe CLI        │───────▶│  SSD    │
│ (raw bytes)  │        │  Harness         │  PCIe  │         │
│              │        │                  │        │         │
│ b'\xC0\x00.. │        │ nvme admin-pass  │        │ FW 실행 │
│              │        │  --opcode=0xC0   │        │         │
│              │        │  --data=...      │        │         │
└──────────────┘        └──────────────────┘        └─────────┘

Harness가 하는 일:
1. 바이트 데이터를 파일로 저장 (/tmp/nvme_fuzz_input)
2. NVMe 커맨드 타입 선택 (Admin / I/O)
3. nvme-cli subprocess 실행
4. 결과/에러 코드 반환
```

### 6.2 지원 커맨드

```
┌─────────────────────────────────────────────────────────────────┐
│                  NVMe Command Matrix                             │
└─────────────────────────────────────────────────────────────────┘

Admin Commands (nvme admin-passthru):
┌──────────────┬────────┬────────────┬────────────┬───────────────┐
│ 명령         │ Opcode │ 데이터 입력│ 데이터 출력│ 퍼징 우선순위 │
├──────────────┼────────┼────────────┼────────────┼───────────────┤
│ Identify     │ 0x06   │     -      │     ✅     │ ★★☆☆☆        │
│ Get Log Page │ 0x02   │     -      │     ✅     │ ★★☆☆☆        │
│ Set Features │ 0x09   │     ✅     │     -      │ ★★★☆☆        │
│ Get Features │ 0x0A   │     -      │     ✅     │ ★★☆☆☆        │
│ FW Download  │ 0x11   │     ✅     │     -      │ ★★★★☆        │
│ FW Commit    │ 0x10   │     -      │     -      │ ★★★★☆        │
│ Vendor Spec  │ 0xC0+  │     ✅     │     ✅     │ ★★★★★        │
└──────────────┴────────┴────────────┴────────────┴───────────────┘

I/O Commands (nvme io-passthru):
┌──────────────┬────────┬────────────┬────────────┬───────────────┐
│ 명령         │ Opcode │ 데이터 입력│ 데이터 출력│ 퍼징 우선순위 │
├──────────────┼────────┼────────────┼────────────┼───────────────┤
│ Write        │ 0x01   │     ✅     │     -      │ ★★★★☆        │
│ Read         │ 0x02   │     -      │     ✅     │ ★★★☆☆        │
└──────────────┴────────┴────────────┴────────────┴───────────────┘

퍼징 우선순위 기준:
★★★★★ = 검증이 적은 코드, 입력 처리 복잡, 취약점 가능성 높음
★☆☆☆☆ = 단순 조회, 검증 충분, 취약점 가능성 낮음
```

---

## 7. 입력 Mutation 전략

```
┌─────────────────────────────────────────────────────────────────┐
│                   Mutation Strategy                               │
└─────────────────────────────────────────────────────────────────┘

Level 1: Byte-level Mutation (기본)
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  원본:  [C0] [00] [01] [00] [00] [02] [00] [00]                │
│                                                                  │
│  Flip:  [C0] [00] [01] [00] [FF] [02] [00] [00]  ← 바이트 변경 │
│  Insert:[C0] [00] [AA] [01] [00] [00] [02] [00]  ← 바이트 삽입 │
│  Delete:[C0] [01] [00] [00] [02] [00] [00]       ← 바이트 삭제 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

Level 2: NVMe-aware Mutation (향후)
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  NVMe Command Structure:                                        │
│  ┌────────┬─────────┬──────┬──────┬──────────────┐             │
│  │ Opcode │ Flags   │ NSID │CDW10 │ Data Payload │             │
│  │ (1B)   │ (1B)    │ (4B) │ (4B) │ (variable)   │             │
│  └────────┴─────────┴──────┴──────┴──────────────┘             │
│                                                                  │
│  구조를 인식하여 특정 필드만 변형:                                │
│  - Opcode 변형 → 다른 커맨드 트리거                             │
│  - CDW10 변형 → 파라미터 퍼징                                   │
│  - Data Payload 변형 → 데이터 처리 로직 퍼징                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

Level 3: Coverage-guided Priority (핵심)
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  Corpus에서 선택 시 우선순위:                                    │
│                                                                  │
│  1. 최근 새 커버리지를 발견한 입력 (가장 높음)                   │
│  2. 적게 변형된 입력                                            │
│  3. 오래된 입력 (다양성 유지)                                    │
│                                                                  │
│  이 입력이 새 코드를 발견 → 이 입력을 더 많이 변형              │
│  → 근처의 추가 코드 경로 발견 확률 ↑                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. 크래시 감지

```
┌─────────────────────────────────────────────────────────────────┐
│                    Crash Detection                               │
└─────────────────────────────────────────────────────────────────┘

방법 1: NVMe 응답 기반
┌─────────────────────────────────────────────────────────────────┐
│  NVMe 커맨드 전송                                               │
│       │                                                          │
│       ├── 정상 응답 (return code 0)     → OK                    │
│       ├── 에러 응답 (return code != 0)  → Error (기록)          │
│       ├── 타임아웃 (응답 없음)          → 잠재적 크래시/행       │
│       └── 장치 사라짐 (/dev/nvme0)      → 크래시 (확실)         │
└─────────────────────────────────────────────────────────────────┘

방법 2: JTAG 기반 (J-Link / Trace32)
┌─────────────────────────────────────────────────────────────────┐
│  JTAG으로 확인 가능:                                            │
│                                                                  │
│  - PC가 Exception Handler에 있음     → 크래시                   │
│  - PC가 특정 에러 함수에 있음         → 에러 감지               │
│  - CPU가 멈춰있음 (HardFault 등)      → 크래시 확실             │
│  - Watchdog Reset 발생                → 행/무한루프 감지        │
└─────────────────────────────────────────────────────────────────┘

방법 3: 조합 (권장)
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  NVMe 타임아웃 발생                                             │
│       │                                                          │
│       ▼                                                          │
│  JTAG으로 PC 확인                                               │
│       │                                                          │
│       ├── Exception Handler → 크래시로 분류                     │
│       ├── 정상 코드 영역    → 느린 처리 (무시)                  │
│       └── 연결 안 됨       → 하드 크래시 (리셋 필요)            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 9. 실행 환경 설정

### 9.1 필요 장비

```
┌──────────────┬─────────────────────────┬────────────────────────┐
│ 장비         │ J-Link 방식             │ Trace32 방식           │
├──────────────┼─────────────────────────┼────────────────────────┤
│ 디버거       │ J-Link V9 (~$50)        │ Trace32 PowerDebug     │
│              │                         │ + PowerTrace (~$10K+)  │
│ 케이블       │ JTAG 20-pin            │ JTAG / Trace Port      │
│ Host PC      │ Ubuntu 20.04+          │ Windows / Linux        │
│ SSD          │ JTAG 포트 노출 필요     │ JTAG + Trace Port     │
│ PCIe 연결    │ PCIe 슬롯 또는 어댑터   │ PCIe 슬롯 또는 어댑터 │
└──────────────┴─────────────────────────┴────────────────────────┘
```

### 9.2 소프트웨어 설치

```bash
# 공통
sudo apt install nvme-cli python3 python3-pip

# J-Link 방식
pip install pylink-square
# + J-Link 소프트웨어 (https://www.segger.com/downloads/jlink/)

# Trace32 방식
# Trace32 PowerView 설치 (Lauterbach 제공)
# + Trace32 Python Remote API
```

### 9.3 연결

```
┌─────────────────────────────────────────────────────────────────┐
│                      Physical Connections                        │
└─────────────────────────────────────────────────────────────────┘

Host PC
  ├── USB ────────── J-Link V9 ──── JTAG ──── SSD JTAG Port
  │   (또는)
  ├── USB/Ethernet ─ Trace32 ────── JTAG ──── SSD JTAG Port
  │
  └── PCIe ──────────────────────────────────── SSD NVMe Port


JTAG Pin Map:
┌─────────┬──────────────┐
│ 디버거  │ SSD JTAG     │
├─────────┼──────────────┤
│ TDI     │ TDI          │
│ TDO     │ TDO          │
│ TCK     │ TCK          │
│ TMS     │ TMS          │
│ nRESET  │ nRESET (opt) │
│ GND     │ GND          │
│ VTref   │ VCC (3.3V)   │
└─────────┴──────────────┘
```

---

## 10. 실행 방법

### 10.1 J-Link 방식

```bash
# 퍼저 실행
python pc_sampling_fuzzer_v2.py \
    --device Cortex-R8 \
    --nvme /dev/nvme0 \
    --commands VendorSpecific Write Read \
    --speed 4000 \
    --runtime 3600 \
    --output ./output/ssd_fuzz/
```

### 10.2 결과 확인

```bash
# 실시간 통계
cat output/ssd_fuzz/stats.json | python3 -m json.tool

# 커버리지 수 확인
wc -l output/ssd_fuzz/coverage.txt

# 크래시 확인
ls output/ssd_fuzz/crashes/

# 코퍼스 확인
ls output/ssd_fuzz/corpus/
```

---

## 11. 퍼징 효과 판단 기준

```
┌─────────────────────────────────────────────────────────────────┐
│                  Effectiveness Metrics                            │
└─────────────────────────────────────────────────────────────────┘

┌───────────────────┬──────────────────────────────────────────┐
│ 지표              │ 설명                                      │
├───────────────────┼──────────────────────────────────────────┤
│ Coverage Growth   │ 시간에 따른 커버리지 증가 곡선            │
│                   │ 계속 증가 = 새 코드 발견 중              │
│                   │ 평탄화 = 더 이상 새 코드 발견 어려움     │
├───────────────────┼──────────────────────────────────────────┤
│ Corpus Size       │ 유효 입력 개수                           │
│                   │ 꾸준히 증가 = 다양한 코드 경로 발견      │
├───────────────────┼──────────────────────────────────────────┤
│ Crashes Found     │ 크래시 발생 입력 수                      │
│                   │ > 0 = 취약점 후보 발견                   │
├───────────────────┼──────────────────────────────────────────┤
│ Exec/sec          │ 초당 실행 횟수                           │
│                   │ 높을수록 효율적                          │
├───────────────────┼──────────────────────────────────────────┤
│ Unique PCs        │ 발견된 고유 PC 주소 수                   │
│                   │ 펌웨어의 몇 %를 커버했는지 추정 가능     │
└───────────────────┴──────────────────────────────────────────┘

커버리지 성장 곡선 (이상적):

Coverage
    │
    │                                    ┌──── 포화 (새 발견 어려움)
    │                              ╱─────┘
    │                        ╱────╱
    │                  ╱────╱
    │            ╱────╱
    │      ╱────╱
    │╱────╱ ← 초기 빠른 성장
    │
    └─────────────────────────────────── Time
```

---

## 12. 프로젝트 구조

```
Real_Fuzzing/
├── pc_sampling_fuzzer_v2.py      # 메인 퍼저 (J-Link)
├── pc_sampling_fuzzer.py         # v1 (참고용)
│
├── PC_Sampling_Fuzzing_Proposal.md   # 기획서
├── PC_Sampling_Review.md             # 기술 검토
├── SSD_Coverage_Fuzzing_Overview.md  # 이 문서
├── GDBFuzz_SSD_Fuzzing_Guide.md     # GDBFuzz 가이드 (이전)
│
├── NVMeConnection.py             # GDBFuzz용 NVMe 연결 (이전)
├── ssd_fuzz.cfg                  # GDBFuzz용 설정 (이전)
│
└── output/                       # 퍼징 결과
    └── pc_sampling_v2/
        ├── corpus/               # 유효 입력
        ├── crashes/              # 크래시
        ├── stats.json            # 통계
        └── coverage.txt          # 커버리지
```

---

## 13. 요약

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  SSD 펌웨어 커버리지 퍼징 시스템                                 │
│                                                                  │
│  Input:     NVMe CLI Harness (admin-passthru / io-passthru)     │
│  Coverage:  J-Link PC Sampling 또는 Trace32 ETM Trace           │
│  Mutation:  Byte-level → NVMe-aware (향후)                      │
│  Target:    ARM Cortex-R8 SSD Controller                        │
│  Goal:      펌웨어 취약점 발견 (크래시, 행, 에러 처리)           │
│                                                                  │
│  장점:                                                          │
│  ✅ 펌웨어 수정 불필요 (바이너리 그대로)                         │
│  ✅ NVMe 표준 인터페이스 사용                                   │
│  ✅ 커버리지 기반으로 블랙박스보다 효과적                        │
│  ✅ J-Link만으로도 시작 가능 (저비용)                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

**프로젝트**: https://github.com/RelaxWide/Real_Fuzzing
